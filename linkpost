#!/Users/cbeck/.asdf/installs/nodejs/24.3.0/bin/node

const fs = require('fs');
const path = require('path');
const cheerio = require('cheerio');
const OpenAI = require('openai');

// Simple HTML title extraction without external dependencies
function extractTitle(html) {
  const titleMatch = html.match(/\u003ctitle[^\u003e]*\u003e([^\u003c]+)\u003c\/title\u003e/i);
  return titleMatch ? titleMatch[1].trim() : 'Untitled';
}

// Extract main content from HTML using semantic tags
function extractMainContent(html) {
  const $ = cheerio.load(html);
  let content = '';
  
  // Try semantic containers in order of preference
  const semanticSelectors = [
    'article',
    'main', 
    '[role="main"]',
    '.content',
    '#content',
    '.post-content',
    '.entry-content',
    'section'
  ];
  
  for (const selector of semanticSelectors) {
    const element = $(selector).first();
    if (element.length > 0) {
      // Remove unwanted elements like nav, aside, footer, ads
      element.find('nav, aside, footer, .ads, .advertisement, .social-share, .comments').remove();
      
      // Extract text from paragraphs, headings, and lists
      const textElements = element.find('p, h1, h2, h3, h4, h5, h6, li').map(function() {
        return $(this).text().trim();
      }).get();
      
      content = textElements.filter(text => text.length > 20).join(' ');
      
      if (content && content.length > 100) { // Ensure meaningful content
        break;
      }
    }
  }
  
  // Fallback: extract all paragraphs
  if (!content) {
    content = $('p').map(function() {
      return $(this).text().trim();
    }).get().filter(text => text.length > 20).join(' ');
  }
  
  // Clean up the text
  content = content.replace(/\s+/g, ' ').trim();
  
  // Limit content length for API efficiency (roughly 3000 words max)
  if (content.length > 12000) {
    content = content.substring(0, 12000) + '...';
  }
  
  return content || 'No content available for summarization.';
}

// Use OpenAI to generate a concise summary
async function generateSummary(content, title, url) {
  try {
    const openai = new OpenAI({
      apiKey: process.env.OPENAI_API_KEY
    });
    
    const prompt = `Please provide a concise 1-3 sentence summary of the following web content. Focus on the main points and key insights. Do not include promotional language or calls to action.

Title: ${title}
URL: ${url}

Content:
${content}`;
    
    const response = await openai.chat.completions.create({
      model: 'gpt-3.5-turbo',
      messages: [
        {
          role: 'user',
          content: prompt
        }
      ],
      max_tokens: 150,
      temperature: 0.3
    });
    
    return response.choices[0].message.content.trim();
    
  } catch (error) {
    console.warn('‚ö†Ô∏è  OpenAI summarization failed:', error.message);
    // Fallback to simple truncation
    const sentences = content.split(/[.!?]+/);
    const summary = sentences.slice(0, 3).join('. ').trim();
    return summary.length > 0 ? summary + '.' : 'Summary not available.';
  }
}

// Create a URL-friendly slug from title
function createSlug(title) {
  return title
    .toLowerCase()
    .replace(/[^a-z0-9\s-]/g, '') // Remove special characters
    .replace(/\s+/g, '-')         // Replace spaces with hyphens
    .replace(/-+/g, '-')          // Replace multiple hyphens with single
    .replace(/^-|-$/g, '');       // Remove leading/trailing hyphens
}

async function scrapeAndCreateLinkpost(url) {
  try {
    console.log(`Fetching: ${url}`);
    
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    const html = await response.text();
    const title = extractTitle(html);
    const mainContent = extractMainContent(html);
    const summary = await generateSummary(mainContent, title, url);
    const slug = createSlug(title);
    const date = new Date().toISOString().split('T')[0];
    const filename = `${date}-${slug}.markdown`;

    // Ensure _posts directory exists
    const postsDir = path.join(__dirname, '_posts');
    if (!fs.existsSync(postsDir)) {
      fs.mkdirSync(postsDir, { recursive: true });
    }

    const filePath = path.join(postsDir, filename);
    const content = `---
layout: post
title: "${title}"
date: ${date}
linkhref: ${url}
categories:
---

[{{ page.title }}]({{ page.linkhref }})

${summary}

`;

    fs.writeFileSync(filePath, content);
    console.log(`‚úÖ Linkpost created: ${filename}`);
    console.log(`üìÑ Title: ${title}`);
    console.log(`üîó URL: ${url}`);
    console.log(`üìç Location: ${filePath}`);
    
  } catch (error) {
    console.error('‚ùå Error:', error.message);
    process.exit(1);
  }
}

// Get the URL from command line arguments
const [,, url] = process.argv;

if (!url) {
  console.error('Usage: ./linkpost <URL>');
  console.error('Example: ./linkpost https://example.com');
  process.exit(1);
}

// Validate URL format
try {
  new URL(url);
} catch {
  console.error('‚ùå Invalid URL format');
  process.exit(1);
}

scrapeAndCreateLinkpost(url);
